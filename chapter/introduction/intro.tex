During the past 50 years, we have seen an important increase numbers of computer and software everywhere in our society to speed up our everyday action as communicate, writing books, searching information, ... and this desire of speed up every action reflect also in work, to take an order, or managing planning, but the software development has not been forgotten, and it's even maybe from this sector that this willing to make process quicker comes from.
\\
In the past, software development would be a job for patient people because each compilation could take hours, so it's been a early concern for developers because it's annoying to find that you miss a semi-columns after 5 hours waiting, so a lot of technique have been created through time to speed up this process with incremental compilation to compile only the modified file or even interpreted language as python or ruby to run directly after a modification.
\\
\\
One big improvement of the software development process have been the parser with static (or dynamic) syntax analysis that check the validity of a program before and warn the developer if something he write is not valid in the language (or more with dynamic analysis). A lot of tools have been written but, as the software become more and more complex with more and more functionality, the size of these program increase too. This increase of size make the work of parsers more difficult as the amount of data to analyse become bigger and bigger and the time to analyse all of these data become slower and slower.
\\
\\
A lot of programming language analysis tools used in IDE, are based on one type of parser like top-down or bottom-up. Each of them have some advantage compare to another, even if generally top-down parsers are best to predict things, bottom-up parsers are quicker in most of the case, so each tools have to chose between these 2 approach and trade between speed and predicatively.
\\
\\
This choice is often made because this tools are based on the actual parser use in the compiler or interpreter of the language, and so re-create from scratch the parser can be difficult.
But it would be interesting to know if another approach of this problem is possible, and this research paper will analyse the problem and propose another approach of parsers inside IDE to offer a quick and predictive parser.
% Going more in precision
% Linter : use more parser than linter